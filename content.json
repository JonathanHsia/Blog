{"meta":{"title":"技术分享","subtitle":"总结技术经验","description":"我思故我在","author":"Jonathan Hsia","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"AndroidStudio3.0项目迁移踩坑","slug":"AndroidStudio3-0项目迁移踩坑","date":"2017-10-27T13:39:00.000Z","updated":"2017-10-28T05:08:58.152Z","comments":true,"path":"2017/10/27/AndroidStudio3-0项目迁移踩坑/","link":"","permalink":"http://yoursite.com/2017/10/27/AndroidStudio3-0项目迁移踩坑/","excerpt":"","text":"AndroidStudio3.0刚刚发布两天,便迫不及待的升级了,升级前也明白这次的版本跨度较大,老项目可能存在很多的问题,没成想还是从中午折腾到了晚上十点.不过结果还不错,成功的跑起来了项目. 列出踩过的坑,希望后面要升级的小伙伴遇到类似的问题可以做个参考; 1.升级安装两种升级方法: 直接用自带的更新工具 操作步骤: &gt;菜单栏&gt;Help&gt;Check for Updates..(前提网络要绝对的畅通,你懂的) 手动的下载新的版本下载地址https://developer.android.google.cn/studio/archive.html#android-studio-3-0?utm_source=androiddevtools.cn&amp;utm_medium=website","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"AndroidStudio","slug":"AndroidStudio","permalink":"http://yoursite.com/tags/AndroidStudio/"}]},{"title":"JNI在Android Studio2.2中基本配置和使用","slug":"Studio2-2中基本配置和使用","date":"2017-09-07T07:46:00.000Z","updated":"2017-09-07T09:35:12.297Z","comments":true,"path":"2017/09/07/Studio2-2中基本配置和使用/","link":"","permalink":"http://yoursite.com/2017/09/07/Studio2-2中基本配置和使用/","excerpt":"","text":"1.是什么?1.JNI (Java Native Interface) 它允许Java代码和其他语言写的代码进行交互。JNI 是本地编程接口，它使得在 Java 虚拟机 (VM) 内部运行的 Java 代码能够与用其它编程语言(如 C、C++ 和汇编语言)编写的应用程序和库进行交互操作。由于Android的应用层的类都是以Java写的，这些Java类编译为Dex型式的Bytecode之后，必须靠Dalvik虚拟机(VM: Virtual Machine)来执行。 2.NDKNative Develop Kit(本地开发工具包),类似于JDK;只是一套工具，它可以帮助开发者在android开发中，它使用的是JNI机制. 3.两者的区别JNI Java Native Interface java调用本地接口 的技术名词NDK Native Developer Kit 谷歌给开发人员的工具包 2.使用ndkBuilder进行项目的构建 1. 下载ndk(已装,略过)进入项目设置界面 没有安装的话,直接Download即可,PS.在最终安装的时候会卡很长时间,耐心等待安装完成 2. 配置app,build.gradle文件 在app的build.gradle中,也就是要运行的项目中的build.gradle文件中的defaultConfig节点中增加12345ndk &#123; moduleName \"NdkJniDemo\" //生成的so名字 ldLibs \"log\", \"z\", \"m\" //添加依赖库文件，因为有log打印等//非必填加项 abiFilters \"armeabi\", \"armeabi-v7a\", \"x86\" //输出指定三种abi体系结构下的so库，目前可有可无。//不填写则生成所有 &#125; 3. 创建本地需要创建调用C的代码,这里使用一个获取字符串的方法为例新建一个工具类JniUtils,使用C获取一个字符串,然后展示到一个 1234public class JniUtils &#123; public static native String getStringFormC(); ...可以有很多的native代码&#125; 使用native关键字,表示调用本地的方法,该方法可以使用C/C++语言来实现 4. 生成.h,C/C++的头文件(熟悉C的知道,可以没有头文件,头文件只是定义类中所有方法(C中没有类的概念)) build或rebuild或clear一下程序之后,会在build/intermediates/classes/debug目录中生成项目中的所有的class文件, 命令行进入debug目录cd &lt;路径&gt; 编译指令1javah -jni com.wobiancao.ndkjnidemo.ndk.JniUtils 注意 这里javah -jni后面跟的是JniUtils类的全路径，如果javah报不存在之 类的，是你的java环境没有配置好。 5. 编译过后会在debug目录下生成一个.h的文件,它的命名方式会很长,基本 是全路径的命名方式 1jonathanhsia_com_ndktest_utils_JniUtils.h 6. 拷贝文件到项目中的main/jni目录下,如果没有直接创建即可 7. 编写C的方法实现 在jni目录下新建C/C++文件,引用头文件,复写其中的java要调用的C/C++方法,返回一个字符串, 8. 在JniUtils中静态导入C/C++所生成的so包123static &#123; System.loadLibrary(\"NdkJniDemo\");//之前在build.gradle里面设置的so名字，必须一致 &#125; 此时run之后java代码即可以调用到用C/C++实现的代码了 “PS. 在run之后,会在build/intermediates/ndk/debug/lib目录下会出现在build.gradle中配置的三种cpu架构的so包,此时删除jni目录中的源码,将这些so包直接的拷入到项目中就可以直接的使用了” 遇到的坑 C/C++不能格式化代码,否则会出现,编译通过(可能编译出错,但是没有阻止运行),运行不了,报出找不到so包的异常 首次run的时候可能报出 1Error: NDK integration is d eprecated in the current plugin. Consider trying the new experimental plugin. For details, see http://tools.android.com/tech-docs/new-build-system/gradle-experimental. Set &quot;android.useDeprecatedNdk=true&quot; in gradle.properties to continue using the current NDK integration. 这样的错误,按照里面的提示在gradle.properties文件中增加android.useDeprecatedNdk=true字段即可 不支持intant run 两个c同时实现h中的方法,会报错,不允许,逻辑上也是不允许; JniUtils的位置不能够随便已经,因为和C/C++文件中是一一对应的引用关系 3.使用cmake进行项目的构建 1. cmake编辑功能是android studio 2.2才支持的新功能;目的是简化jni的开发过程,使用studio2.2新建项目的话,会有相应的让你勾选使用cmake 2.当勾选了include C++ Support时,在创建项目的时候,会多出如上界面,选择C/C++的标准,此处的设置在app的build.gradle中的defaultConfig会增加设置 123456 externalNativeBuild &#123; cmake &#123; cppFlags \"-frtti -fexceptions\"//这个标记是第一个选项,如果使用C++11的标准,则使用 //cppFlags \"-std=c++11\" &#125;&#125; 3.在build.gradle中的android节点下面会增加配置,指定生成so文件配置文件的路径 12345externalNativeBuild &#123; cmake &#123; path \"CMakeLists.txt\" &#125; &#125; 4.创建需要调用C/C++代码的java代码,和ndkBuilder相同 123public class JniUtils &#123; public static native String getStrFromC2();&#125; 5.在项目中src/main/中创建cpp目录,里面可以直接的创建cpp源代码,和ndkBuild一样,用C/C++所写的源代码中的方法名称必须是全路径的方法名,然后以Java开头,分割使用下划线. 123456789#include &lt;jni.h&gt;#include &lt;string&gt;extern \"C\"jstringJava_com_ndkcmaketestapp_utils_JniUtils_getStrFromC2(JNIEnv *env, jobject thiz) &#123; std::string hello = \"Hello from C++ Two!\"; return env-&gt;NewStringUTF(hello.c_str());&#125; 6.CMakeLists.txt文件中的具体配置 123cmake_minimum_required(VERSION 3.4.1) #指定cmake版本add_library(form SHARED src/main/cpp/form.cpp) #hello是生成的so文件的名称,要和cpp文件的名称相同target_link_libraries(hello log android) # 此处增加了,日志的链接库 7.在java代码中增加引用so库的代码,使代码生效 12345678public class JniUtils &#123; // Used to load the 'native-lib' library on application startup. static &#123; System.loadLibrary(\"form\");//此处的form库的名称需要和CMakeLists.txt中配置的相同 &#125; public static native String getStrFromC2();&#125; 8.在run成功之后,会在build目录的上方增加.externalNativeBuild目录,其中.externalNativeBuild/cmake/debug/obj包含所有生成的so包,同样的拷贝到项目中的jniLibs就可以直接的使用 CMake的优势 1.可以直接的在C/C++代码中加入断点,进行调试 2.java引用的C/C++中的方法,可以直接ctrl+左键进入 3.对于include的头文件,或者库,也可以直接的进入 4.不需要配置命令行操作,手动的生成头文件,不需要配置android.useDeprecatedNdk=true属性","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"jni","slug":"jni","permalink":"http://yoursite.com/tags/jni/"}]}]}